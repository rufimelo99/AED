int tsp_v2(int initial_node, int amount_of_cities, int mask[amount_of_cities]){
  //void tsp_v3(int initial_node, int amount_of_cities, int mask[amount_of_cities]){
  int n_opcoes=0;
  int min_temp=999999; //numero demasiado grande


  //ocupar na mascara o node usado
  mask[initial_node]=1;
  
  //imprimir mascara
  if DEBUG {
    printf("mask-->");
  }
  for(int i=0; i<amount_of_cities; i++){  
    if DEBUG {
      printf("%3i ", mask[i]);  
    } 
      if(mask[i]==0){
        n_opcoes++;
        
      }
  }

  //determinar a quantidade de cidades que falta comparar e verificar
  int cidades_em_falta[n_opcoes];
  int counter=0;
  for(int i=0; i<amount_of_cities; i++){
    if(mask[i]==0){
      cidades_em_falta[counter]=i;
      counter++;
    }
  }
  if DEBUG {
    printf("\nn_opcoes:  %i\n", n_opcoes);
    printf("\ncidades em falta:  ");
 
    for(int i=0; i<n_opcoes; i++){
      printf("%i ", cidades_em_falta[i]);
    }
    printf("\n");
   }
  /*
 
  T (0, {1,2,3})= minimum of

  = { (0,1)  + T (1,  {2,3} )     -->matriz[0][1] + tsp_v3(1, {1,1,0,0})

  = { (0,2)  + T (2,  {1,3} )     -->matriz[0][2] + tsp_v3(2, {1,0,1,0})

  = { (0,3)  + T (3,  {1,2} )     -->matriz[0][3] + tsp_v3(3, {1,0,0,1});
  */
  if(n_opcoes==0){
    min_temp=matriz[initial_node][0];//supostamente 0 pq comecamos nesta cidade

  }
  else{
    for(int i=0; i<n_opcoes; i++){  
      //criar mascara nova
      int mask_temp[amount_of_cities];
      for(int j=0; j<amount_of_cities; j++){
        mask_temp[j]=mask[j];
      }
      mask_temp[cidades_em_falta[i]]=1;
      //


      int valor= matriz[cidades_em_falta[i]][initial_node] + tsp_v2(cidades_em_falta[i], amount_of_cities, mask_temp);
      if DEBUG{
        printf("cidade em falta: %i\n", cidades_em_falta[i]);
        printf("distancia a cidade original: %i\n", valor);
      
        printf("valor: %i\n", valor);
      }
      if(valor<min_temp){
        min_temp=valor;
        //printf("trocou\n");
      }
    }
  }
  
  return min_temp;

}
